#include <avr/pgmspace.h>
#include <EEPROM.h>
#include <EncoderButton.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define OLED_RESET    -1 
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

#define SCREEN_ADDRESS 0x3C   ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);


#define LDR_PIN_1 9
#define LDR_PIN_2 10

#define LED_PIN_1 5
#define LED_PIN_2 6

#define LED_PIN_ON 14

#define EXPRESSION_DETECT_PIN 15
#define EXPRESSION_VALUE_PIN 0

#define MAX_SPEED 250
#define MIN_SPEED -16

#define DEPTH_SPEED 4

#define MODE_COUNT 8


const uint8_t SINE_WAVE[] PROGMEM = {
0x7F,0x82,0x85,0x88,0x8B,0x8F,0x92,0x95,0x98,0x9B,
0x9E,0xA1,0xA4,0xA7,0xAA,0xAD,0xB0,0xB2,0xB5,0xB8,
0xBB,0xBE,0xC0,0xC3,0xC6,0xC8,0xCB,0xCD,0xD0,0xD2,
0xD4,0xD7,0xD9,0xDB,0xDD,0xDF,0xE1,0xE3,0xE5,0xE7,
0xE9,0xEA,0xEC,0xEE,0xEF,0xF0,0xF2,0xF3,0xF4,0xF5,
0xF7,0xF8,0xF9,0xF9,0xFA,0xFB,0xFC,0xFC,0xFD,0xFD,
0xFD,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFD,0xFD,
0xFD,0xFC,0xFC,0xFB,0xFA,0xF9,0xF9,0xF8,0xF7,0xF5,
0xF4,0xF3,0xF2,0xF0,0xEF,0xEE,0xEC,0xEA,0xE9,0xE7,
0xE5,0xE3,0xE1,0xDF,0xDD,0xDB,0xD9,0xD7,0xD4,0xD2,
0xD0,0xCD,0xCB,0xC8,0xC6,0xC3,0xC0,0xBE,0xBB,0xB8,
0xB5,0xB2,0xB0,0xAD,0xAA,0xA7,0xA4,0xA1,0x9E,0x9B,
0x98,0x95,0x92,0x8F,0x8B,0x88,0x85,0x82,0x7F,0x7C,
0x79,0x76,0x73,0x6F,0x6C,0x69,0x66,0x63,0x60,0x5D,
0x5A,0x57,0x54,0x51,0x4E,0x4C,0x49,0x46,0x43,0x40,
0x3E,0x3B,0x38,0x36,0x33,0x31,0x2E,0x2C,0x2A,0x27,
0x25,0x23,0x21,0x1F,0x1D,0x1B,0x19,0x17,0x15,0x14,
0x12,0x10,0x0F,0x0E,0x0C,0x0B,0x0A,0x09,0x07,0x06,
0x05,0x05,0x04,0x03,0x02,0x02,0x01,0x01,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,
0x02,0x03,0x04,0x05,0x05,0x06,0x07,0x09,0x0A,0x0B,
0x0C,0x0E,0x0F,0x10,0x12,0x14,0x15,0x17,0x19,0x1B,
0x1D,0x1F,0x21,0x23,0x25,0x27,0x2A,0x2C,0x2E,0x31,
0x33,0x36,0x38,0x3B,0x3E,0x40,0x43,0x46,0x49,0x4C,
0x4E,0x51,0x54,0x57,0x5A,0x5D,0x60,0x63,0x66,0x69,
0x6C,0x6F,0x73,0x76,0x79,0x7C
};

const uint8_t TAN_WAVE[] PROGMEM = {
0x7F,0x82,0x85,0x88,0x8B,0x8F,0x92,0x95,0x98,0x9B,
0x9E,0xA1,0xA4,0xA7,0xAA,0xAD,0xB0,0xB2,0xB5,0xB8,
0xBB,0xBE,0xC0,0xC3,0xC6,0xC8,0xCB,0xCD,0xD0,0xD2,
0xD4,0xD7,0xD9,0xDB,0xDD,0xDF,0xE1,0xE3,0xE5,0xE7,
0xE9,0xEA,0xEC,0xEE,0xEF,0xF0,0xF2,0xF3,0xF4,0xF5,
0xF7,0xF8,0xF9,0xF9,0xFA,0xFB,0xFC,0xFC,0xFD,0xFD,
0xFD,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFD,0xFD,
0xFD,0xFC,0xFC,0xFB,0xFA,0xF9,0xF9,0xF8,0xF7,0xF5,
0xF4,0xF3,0xF2,0xF0,0xEF,0xEE,0xEC,0xEA,0xE9,0xE7,
0xE5,0xE3,0xE1,0xDF,0xDD,0xDB,0xD9,0xD7,0xD4,0xD2,
0xD0,0xCD,0xCB,0xC8,0xC6,0xC3,0xC0,0xBE,0xBB,0xB8,
0xB5,0xB2,0xB0,0xAD,0xAA,0xA7,0xA4,0xA1,0x9E,0x9B,
0x98,0x95,0x92,0x8F,0x8B,0x88,0x85,0x82,0x7F,0x7C,
0x79,0x76,0x73,0x6F,0x6C,0x69,0x66,0x63,0x60,0x5D,
0x5A,0x57,0x54,0x51,0x4E,0x4C,0x49,0x46,0x43,0x40,
0x3E,0x3B,0x38,0x36,0x33,0x31,0x2E,0x2C,0x2A,0x27,
0x25,0x23,0x21,0x1F,0x1D,0x1B,0x19,0x17,0x15,0x14,
0x12,0x10,0x0F,0x0E,0x0C,0x0B,0x0A,0x09,0x07,0x06,
0x05,0x05,0x04,0x03,0x02,0x02,0x01,0x01,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,
0x02,0x03,0x04,0x05,0x05,0x06,0x07,0x09,0x0A,0x0B,
0x0C,0x0E,0x0F,0x10,0x12,0x14,0x15,0x17,0x19,0x1B,
0x1D,0x1F,0x21,0x23,0x25,0x27,0x2A,0x2C,0x2E,0x31,
0x33,0x36,0x38,0x3B,0x3E,0x40,0x43,0x46,0x49,0x4C,
0x4E,0x51,0x54,0x57,0x5A,0x5D,0x60,0x63,0x66,0x69,
0x6C,0x6F,0x73,0x76,0x79,0x7C
};

const uint8_t SAW_WAVE[] PROGMEM = {
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
0x3C,0x3D,0x3E,0x3F,0x40,0x40,0x41,0x42,0x43,0x44,
0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,
0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,
0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,
0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,
0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,
0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x80,
0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,
0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,
0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,
0x9F,0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,
0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,
0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,
0xBD,0xBE,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,
0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,
0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,
0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
0xF8,0xF9,0xFA,0xFB,0xFC,0xFD };

const uint8_t RSAW_WAVE[] PROGMEM = {
0xFE,0xFD,0xFC,0xFB,0xFA,0xF9,0xF8,0xF7,0xF6,0xF5,
0xF4,0xF3,0xF2,0xF1,0xF0,0xEF,0xEE,0xED,0xEC,0xEB,
0xEA,0xE9,0xE8,0xE7,0xE6,0xE5,0xE4,0xE3,0xE2,0xE1,
0xE0,0xDF,0xDE,0xDD,0xDC,0xDB,0xDA,0xD9,0xD8,0xD7,
0xD6,0xD5,0xD4,0xD3,0xD2,0xD1,0xD0,0xCF,0xCE,0xCD,
0xCC,0xCB,0xCA,0xC9,0xC8,0xC7,0xC6,0xC5,0xC4,0xC3,
0xC2,0xC1,0xC0,0xBF,0xBE,0xBE,0xBD,0xBC,0xBB,0xBA,
0xB9,0xB8,0xB7,0xB6,0xB5,0xB4,0xB3,0xB2,0xB1,0xB0,
0xAF,0xAE,0xAD,0xAC,0xAB,0xAA,0xA9,0xA8,0xA7,0xA6,
0xA5,0xA4,0xA3,0xA2,0xA1,0xA0,0x9F,0x9E,0x9D,0x9C,
0x9B,0x9A,0x99,0x98,0x97,0x96,0x95,0x94,0x93,0x92,
0x91,0x90,0x8F,0x8E,0x8D,0x8C,0x8B,0x8A,0x89,0x88,
0x87,0x86,0x85,0x84,0x83,0x82,0x81,0x80,0x7F,0x7E,
0x7D,0x7C,0x7B,0x7A,0x79,0x78,0x77,0x76,0x75,0x74,
0x73,0x72,0x71,0x70,0x6F,0x6E,0x6D,0x6C,0x6B,0x6A,
0x69,0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,0x60,
0x5F,0x5E,0x5D,0x5C,0x5B,0x5A,0x59,0x58,0x57,0x56,
0x55,0x54,0x53,0x52,0x51,0x50,0x4F,0x4E,0x4D,0x4C,
0x4B,0x4A,0x49,0x48,0x47,0x46,0x45,0x44,0x43,0x42,
0x41,0x40,0x40,0x3F,0x3E,0x3D,0x3C,0x3B,0x3A,0x39,
0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x2F,
0x2E,0x2D,0x2C,0x2B,0x2A,0x29,0x28,0x27,0x26,0x25,
0x24,0x23,0x22,0x21,0x20,0x1F,0x1E,0x1D,0x1C,0x1B,
0x1A,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,
0x10,0x0F,0x0E,0x0D,0x0C,0x0B,0x0A,0x09,0x08,0x07,
0x06,0x05,0x04,0x03,0x02,0x01 };



const uint8_t TRIANGLE_WAVE[] PROGMEM = {
0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,
0x14,0x16,0x18,0x1A,0x1C,0x1E,0x20,0x22,0x24,0x26,
0x28,0x2A,0x2C,0x2E,0x30,0x32,0x34,0x36,0x38,0x3A,
0x3C,0x3E,0x40,0x41,0x43,0x45,0x47,0x49,0x4B,0x4D,
0x4F,0x51,0x53,0x55,0x57,0x59,0x5B,0x5D,0x5F,0x61,
0x63,0x65,0x67,0x69,0x6B,0x6D,0x6F,0x71,0x73,0x75,
0x77,0x79,0x7B,0x7D,0x7F,0x81,0x83,0x85,0x87,0x89,
0x8B,0x8D,0x8F,0x91,0x93,0x95,0x97,0x99,0x9B,0x9D,
0x9F,0xA1,0xA3,0xA5,0xA7,0xA9,0xAB,0xAD,0xAF,0xB1,
0xB3,0xB5,0xB7,0xB9,0xBB,0xBD,0xBE,0xC0,0xC2,0xC4,
0xC6,0xC8,0xCA,0xCC,0xCE,0xD0,0xD2,0xD4,0xD6,0xD8,
0xDA,0xDC,0xDE,0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEC,
0xEE,0xF0,0xF2,0xF4,0xF6,0xF8,0xFA,0xFC,0xFE,0xFC,
0xFA,0xF8,0xF6,0xF4,0xF2,0xF0,0xEE,0xEC,0xEA,0xE8,
0xE6,0xE4,0xE2,0xE0,0xDE,0xDC,0xDA,0xD8,0xD6,0xD4,
0xD2,0xD0,0xCE,0xCC,0xCA,0xC8,0xC6,0xC4,0xC2,0xC0,
0xBE,0xBD,0xBB,0xB9,0xB7,0xB5,0xB3,0xB1,0xAF,0xAD,
0xAB,0xA9,0xA7,0xA5,0xA3,0xA1,0x9F,0x9D,0x9B,0x99,
0x97,0x95,0x93,0x91,0x8F,0x8D,0x8B,0x89,0x87,0x85,
0x83,0x81,0x7F,0x7D,0x7B,0x79,0x77,0x75,0x73,0x71,
0x6F,0x6D,0x6B,0x69,0x67,0x65,0x63,0x61,0x5F,0x5D,
0x5B,0x59,0x57,0x55,0x53,0x51,0x4F,0x4D,0x4B,0x49,
0x47,0x45,0x43,0x41,0x40,0x3E,0x3C,0x3A,0x38,0x36,
0x34,0x32,0x30,0x2E,0x2C,0x2A,0x28,0x26,0x24,0x22,
0x20,0x1E,0x1C,0x1A,0x18,0x16,0x14,0x12,0x10,0x0E,
0x0C,0x0A,0x08,0x06,0x04,0x02
};

const uint8_t SQUARE_WAVE[] PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};


const uint8_t SIGMOID_WAVE[] PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x03,
0x03,0x03,0x03,0x03,0x04,0x04,0x04,0x05,0x05,0x05,
0x06,0x06,0x07,0x07,0x08,0x09,0x09,0x0A,0x0B,0x0C,
0x0C,0x0D,0x0E,0x10,0x11,0x12,0x13,0x15,0x16,0x18,
0x1A,0x1C,0x1E,0x20,0x22,0x24,0x27,0x29,0x2C,0x2F,
0x32,0x35,0x39,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,
0x59,0x5D,0x62,0x67,0x6C,0x71,0x76,0x7B,0x7F,0x84,
0x89,0x8E,0x93,0x98,0x9D,0xA2,0xA6,0xAB,0xAF,0xB3,
0xB7,0xBB,0xBF,0xC3,0xC6,0xCA,0xCD,0xD0,0xD3,0xD6,
0xD8,0xDB,0xDD,0xDF,0xE1,0xE3,0xE5,0xE7,0xE9,0xEA,
0xEC,0xED,0xEE,0xEF,0xF1,0xF2,0xF3,0xF3,0xF4,0xF5,
0xF6,0xF6,0xF7,0xF8,0xF8,0xF9,0xF9,0xFA,0xFA,0xFA,
0xFB,0xFB,0xFB,0xFC,0xFC,0xFC,0xFC,0xFC,0xFD,0xFD,
0xFD,0xFD,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

const uint8_t WHITENOISE_WAVE[] PROGMEM = {
0x6F,0x7C,0xEC,0x8F,0xA1,0x59,0xA1,0xF6,0x0E,0x2C,
0xF5,0xB0,0xED,0x27,0xBC,0xDB,0x93,0x5F,0x90,0x71,
0x3F,0x05,0x6A,0xE3,0x51,0xE1,0xC7,0xF3,0x62,0x79,
0x22,0x0F,0x8E,0xB1,0xC7,0x68,0xC3,0x17,0x29,0xF4,
0x82,0x12,0x25,0x58,0xD8,0x35,0x04,0x43,0x6A,0x88,
0xAB,0x2A,0xD8,0x3B,0xD7,0xAA,0xE2,0x5E,0x9C,0xD0,
0x56,0xFA,0x23,0xD1,0x43,0xAF,0xEE,0xB6,0xB5,0x08,
0xB9,0xCF,0xEC,0x59,0xC4,0x91,0x47,0x6D,0x4E,0x4E,
0xB1,0xAB,0x07,0x53,0x15,0x54,0xBB,0x35,0xB5,0x6E,
0xB9,0xB6,0x1A,0xE6,0x60,0x30,0x64,0x3F,0x48,0x51,
0x57,0xF2,0x90,0x85,0x85,0xF9,0xE9,0xE8,0xF5,0x61,
0x4C,0xC8,0x96,0xDB,0x7F,0x49,0x3B,0xE4,0xF1,0xEC,
0x03,0x64,0x8D,0xAE,0x04,0x9F,0x18,0x41,0xCF,0xF4,
0xD5,0x88,0xAC,0x8D,0x68,0x34,0xB3,0x0D,0xFD,0x46,
0xC0,0x95,0x28,0x6A,0xFC,0x7D,0x7C,0xD1,0x87,0x7B,
0xF4,0x9F,0x21,0x5D,0xC6,0x90,0x3A,0xE3,0x69,0x42,
0x59,0x04,0x4A,0x7C,0x3B,0x03,0x94,0xF5,0x8F,0x22,
0x55,0x2E,0x2C,0xA0,0x85,0x55,0x05,0x7E,0xFA,0xC6,
0x50,0x4B,0xC5,0x91,0x1B,0xF9,0x7F,0x19,0x88,0x51,
0x77,0x82,0xDB,0xD7,0xC2,0x61,0x27,0xCA,0x2B,0xB0,
0x44,0x84,0xA3,0xFA,0x81,0xF7,0x68,0x31,0x38,0x10,
0xD1,0xEA,0xB4,0x28,0x20,0x91,0x9D,0x72,0xD1,0x9D,
0x35,0xC5,0x32,0xB7,0xE8,0x93,0x68,0xCE,0x27,0x17,
0xA9,0xCC,0x67,0xAC,0x0C,0x23,0xA1,0x28,0x19,0xF1,
0x05,0x73,0x99,0x82,0x06,0x40,0x82,0xE9,0xD7,0xD7,
0x48,0x2B,0x47,0x72,0xF9,0x15 };

const uint8_t GAUSS_WAVE[] PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,
0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x04,
0x04,0x04,0x05,0x05,0x06,0x06,0x07,0x07,0x08,0x09,
0x09,0x0A,0x0B,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x12,
0x13,0x14,0x15,0x17,0x18,0x1A,0x1C,0x1D,0x1F,0x21,
0x23,0x25,0x27,0x2A,0x2C,0x2E,0x31,0x34,0x36,0x39,
0x3C,0x3F,0x42,0x46,0x49,0x4C,0x50,0x54,0x57,0x5B,
0x5F,0x63,0x67,0x6B,0x6F,0x73,0x78,0x7C,0x80,0x85,
0x89,0x8E,0x92,0x97,0x9B,0xA0,0xA4,0xA9,0xAD,0xB2,
0xB6,0xBA,0xBF,0xC3,0xC7,0xCB,0xCF,0xD3,0xD7,0xDA,
0xDE,0xE1,0xE4,0xE8,0xEA,0xED,0xF0,0xF2,0xF4,0xF6,
0xF8,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFE,0xFD,0xFC,0xFB,0xFA,0xF8,0xF6,0xF4,0xF2,
0xF0,0xED,0xEA,0xE8,0xE4,0xE1,0xDE,0xDA,0xD7,0xD3,
0xCF,0xCB,0xC7,0xC3,0xBF,0xBA,0xB6,0xB2,0xAD,0xA9,
0xA4,0xA0,0x9B,0x97,0x92,0x8E,0x89,0x85,0x80,0x7C,
0x78,0x73,0x6F,0x6B,0x67,0x63,0x5F,0x5B,0x57,0x54,
0x50,0x4C,0x49,0x46,0x42,0x3F,0x3C,0x39,0x36,0x34,
0x31,0x2E,0x2C,0x2A,0x27,0x25,0x23,0x21,0x1F,0x1D,
0x1C,0x1A,0x18,0x17,0x15,0x14,0x13,0x12,0x10,0x0F,
0x0E,0x0D,0x0C,0x0B,0x0B,0x0A,0x09,0x09,0x08,0x07,
0x07,0x06,0x06,0x05,0x05,0x04,0x04,0x04,0x03,0x03,
0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00 };


char *MODE_NAMES[] = { "1 SINE", "2 TRIANGLE",  "3 SAW", "4 REV. SAW", "5 SQUARE", "6 SIGMOID", "7 W.NOISE", "8 GAUSS" };
char *PARAM_NAMES[] = { "Enabled", "Mode", "Speed", "Depth", "Phase", "Volume" };



uint8_t PARAMS[] = { 
    0,      //0 Enabled
    0,      //1 Mode
    16,     //2 Speed
    128,    //3 MAX_BRIGHTNESS ("Depth")
    128,    //4 Phase
    0       //5 MIN_BRIGHTNESS ("Volume")
  };



uint8_t PARAMS_1[] = { 2 };
uint8_t PARAMS_2[] = { 3, 4};

uint8_t CUR_PARAM_1 = 0;
uint8_t CUR_PARAM_2 = 0;

uint8_t *ENABLED = &PARAMS[0];
uint8_t *MODE = &PARAMS[1];
uint8_t *MAX_BRIGHTNESS = &PARAMS[3];
uint8_t *PHASE =  &PARAMS[4];
uint8_t *MIN_BRIGHTNESS = &PARAMS[5];



uint8_t WAVE_INDEX = 0;
uint8_t LDR1_VALUE = 0;
uint8_t LDR2_VALUE = 0;

bool enabled = false;

float R;
unsigned long previous_millis = 0;
long NON_BLOCKING_INTERVAL = 0;  // interval at which to blink (milliseconds)
long FADE_SPEED = 16;
long SPEED_COUNTER = 0;





unsigned long prev_tap_millis = 0;
unsigned long new_tap_millis = 0;

bool expression_connected = false;
unsigned long expression_value = 0;


EncoderButton eb1(0, 1, 4);
EncoderButton eb2(7, 20, 21);
EncoderButton sw1(8);
EncoderButton sw2(16);


void setup_fast_pwm(){
  // Fast PWM AtMega32u4
  // Clear Timer/Counter Control Register A & B
  TCCR1A = 0;
  TCCR1B = 0;

  // Table 14-4. Waveform Generation Mode Bit Description. Page 133
  // Mode:7 - 0 1 1 1 - Fast PWM, 10-bit 0x03FF TOP TOP
  TCCR1B |= (0 << WGM13) | (1 << WGM12);  TCCR1A |= (1 << WGM11) | (1 << WGM10);

  // Table 14-5. Clock Select Bit Description. Page 134
  // 0 0 1 ..   /1 = 15.62 kHz PWM
  // 0 1 0 ..   /8 =  1.95 kHz
  // 0 1 1 ..  /64 =    244 Hz
  // 1 0 0 .. /256 =    61 Hz
  TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10); // 0 0 1 ... clkIO/1 (No prescaling)

  // Table 15-7. Compare Output Mode, Phase and Frequency Correct PWM Mode. Page 165
  // COM4A1..0 = 0b10
  //   Cleared on Compare Match when up-counting.
  //   Set on Compare Match when down-counting. 
  TCCR1A |= (1 << COM1A1) | (0 << COM1A0) | (1 << COM1B1);
  
  // Define Arduino PIN 9 as output. Page 75
  // (PCINT5/OC1A/#OC4B/ADC12) PB5 --> Port B Bit 5 --> Package Pin 29 --> Arduino Pin 9
  /* 
    OC.4B: Timer 4 Output Compare B. This pin can be used to generate a high-speed PWM signal from Timer 4
    module, complementary to OC.4B (PB5) signal. The pin has to be configured as an output (DDB5 set (one)) to
    serve this function. 
  */
  //DDRB |= (1 << DDB5);
  //DDRB |= (1 << DDB6);
  //PORTB |= (0<<PB5);
}



void sw1Pressed(EncoderButton& eb) {
  unsigned long current_tap_millis = micros();
  new_tap_millis = current_tap_millis - prev_tap_millis;
  FADE_SPEED = new_tap_millis / 1000000;
  prev_tap_millis = current_tap_millis;
  update_display();
}

void sw2Pressed(EncoderButton& eb) {

  enabled = !enabled;

  if(!enabled){
    disableLDR();
  }
  else{
    enableLDR();
  }

  Serial.print("ENABLED: ");
  Serial.println(enabled);
  update_display();
}

void enableLDR(){
    setup_fast_pwm();
    DDRB |= (1 << DDB5);
    DDRB |= (1 << DDB6);
    enabled = true;
    digitalWrite(LED_PIN_ON, HIGH);
    display.invertDisplay(true);
}

void disableLDR(){
    digitalWrite(LDR_PIN_1,LOW);
    digitalWrite(LDR_PIN_2,LOW);
    DDRB |= (0 << DDB5);
    DDRB |= (0 << DDB6);
    enabled = false;
    digitalWrite(LED_PIN_ON, LOW);
    display.invertDisplay(false);
    
}

void onEb1Pressed(EncoderButton& eb) {

  if(++*MODE >= MODE_COUNT)
    *MODE = 0;
  Serial.print("MODE: ");
  Serial.println(*MODE);
  update_display();
}


void onEb1Encoder(EncoderButton& eb) {

  FADE_SPEED += eb.increment();

  if(FADE_SPEED >= MAX_SPEED)
    FADE_SPEED = MAX_SPEED;
  else if(FADE_SPEED <= MIN_SPEED)
    FADE_SPEED = MIN_SPEED;

 
  Serial.print("SPEED");
  Serial.print(" = ");
  
  Serial.println(FADE_SPEED);
  //EEPROM.put(0, SPEED);
  update_display();
}

void onEb2Encoder(EncoderButton& eb) {

  /*
  MAX_BRIGHTNESS += eb.increment() * DEPTH_SPEED;
  if(MAX_BRIGHTNESS >= 255)
    MAX_BRIGHTNESS = 255;
  else if(MAX_BRIGHTNESS <= 0)
    MAX_BRIGHTNESS = 0;
  */
  //*PHASE += eb.increment() * DEPTH_SPEED;
  
  PARAMS[PARAMS_2[CUR_PARAM_2]] += eb.increment();

  update_display();

}

void onEb2Pressed(EncoderButton& eb) {
  // change Param2
  uint8_t c = sizeof(PARAMS_2)/sizeof(PARAMS_2[0]);

  CUR_PARAM_2++;
  if(CUR_PARAM_2 >= c)
    CUR_PARAM_2 = 0;

  Serial.print("CUR_PARAM_2:");  Serial.print(CUR_PARAM_2); Serial.print("=>");  Serial.print(PARAMS_2[CUR_PARAM_2]); Serial.print("=>"); Serial.println(PARAM_NAMES[PARAMS_2[CUR_PARAM_2]]);
  
  //EEPROM.put(2, MAX_BRIGHTNESS);

  update_display();
}

void update_display(){
  display.clearDisplay();
  display.setTextSize(2); // Draw 2X-scale text
  display.setTextColor(SSD1306_WHITE);
  //display.println(enabled ? "ON" : "OFF");
  //display.setTextSize(1); // Draw 2X-scale text
  display.setCursor(2, 2);

  display.println(MODE_NAMES[*MODE]);

  display.setTextSize(1); // Draw 2X-scale text

  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 32);
  drawProgressbar(2,20,124,16, map(FADE_SPEED,MIN_SPEED,MAX_SPEED,0,98) ); // int x, int y, int width, int height, value

  display.setCursor(6, 24);
  display.setTextColor(SSD1306_INVERSE);
  display.print("Speed");

  display.setTextColor(SSD1306_WHITE);
  drawProgressbar(2,38,124,16, map(PARAMS[PARAMS_2[CUR_PARAM_2]],0,255,0,98) ); // int x, int y, int width, int height, value
  display.setCursor(6, 42);
  display.setTextColor(SSD1306_INVERSE);
  display.print(PARAM_NAMES[PARAMS_2[CUR_PARAM_2]]);

  // --- DEBUG
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 56);
  display.print("S:"); display.print(FADE_SPEED); display.print(" D:"); display.print(*MAX_BRIGHTNESS); display.print(" P:"); display.print(*PHASE); display.println("");
  // --- DEBUG

  display.display();      // Show initial text
}


void setup() {
  setup_fast_pwm();

  Serial.begin(115200);

  eb1.setPressedHandler(onEb1Pressed);
  eb2.setPressedHandler(onEb2Pressed);

  sw1.setPressedHandler(sw1Pressed);
  sw2.setPressedHandler(sw2Pressed);

  eb1.setEncoderHandler(onEb1Encoder);
  eb2.setEncoderHandler(onEb2Encoder);

  // Calculate linear factor
  R = (255 * log10(2))/(log10(255));

  pinMode(0,INPUT_PULLUP);
  pinMode(1,INPUT_PULLUP);
  pinMode(5,INPUT_PULLUP);
  pinMode(LED_PIN_ON,OUTPUT);
  pinMode(EXPRESSION_DETECT_PIN,INPUT_PULLUP);


  
  

  //EEPROM.get(0, interval);

  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  update_display();

}


void write_output(){


  int led_brightness_1 = pow (2, (LDR1_VALUE / R)) - 1; // helligkeitsanpassung
  int led_brightness_2 = pow (2, (LDR2_VALUE / R)) - 1; // helligkeitsanpassung

  led_brightness_1 = map(led_brightness_1, 0, 255, *MIN_BRIGHTNESS, *MAX_BRIGHTNESS);
  led_brightness_2 = map(led_brightness_2, 0, 255, *MIN_BRIGHTNESS, *MAX_BRIGHTNESS);

  if(enabled){
    OCR1A = led_brightness_1;// Pin 9   LDR 1
    OCR1B = led_brightness_2;// Pin 10  LDR 2
    }
  else{
    OCR1A = 0; // Pin 9 LDR
    OCR1B = 0; // Pin 10 LDR
  }
 
  analogWrite(LED_PIN_1, *MAX_BRIGHTNESS-led_brightness_1); // kontroll led 1
  analogWrite(LED_PIN_2, *MAX_BRIGHTNESS-led_brightness_2); // kontroll led 2

}

void loop() {

  

  // Expression Pedal
  // detection
  bool expression_connected_changed = expression_connected;
  expression_connected = digitalRead(EXPRESSION_DETECT_PIN);
  if(expression_connected_changed != expression_connected){
    expression_connected_changed = expression_connected;
    update_display();
  }
  // auswertung
  if(expression_connected){
    expression_value = map(analogRead(EXPRESSION_VALUE_PIN),0,1023,0,255);

    //Serial.println(expression_value);
  }
  long wave_increment = 0;
  NON_BLOCKING_INTERVAL = FADE_SPEED;


  
  if(FADE_SPEED < 0){
    NON_BLOCKING_INTERVAL = 0;
    wave_increment = FADE_SPEED * -1;

  }
  else{
    NON_BLOCKING_INTERVAL = FADE_SPEED * 100;
    wave_increment = 1;
  }
  

  // non-blocking interval
   unsigned long current_millis = micros();
  if (current_millis - previous_millis >= NON_BLOCKING_INTERVAL) {
    previous_millis = current_millis;
    WAVE_INDEX += wave_increment;


  }

  uint8_t phase1 = (uint8_t)(WAVE_INDEX);
  uint8_t phase2 = (uint8_t)(WAVE_INDEX+*PHASE);

  switch(*MODE){
    case 0: // SINE
        LDR1_VALUE = pgm_read_byte(SINE_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(SINE_WAVE + phase2);
        break;
    case 1: // TRIANGLE
        LDR1_VALUE = pgm_read_byte(TRIANGLE_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(TRIANGLE_WAVE + phase2);
        break;
    case 2: // SAW
        LDR1_VALUE = pgm_read_byte(SAW_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(SAW_WAVE + phase2);
        break;
    case 3: // Reverse SAW
        LDR1_VALUE = pgm_read_byte(RSAW_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(RSAW_WAVE + phase2);
        break;
    case 4: // SQUARE
        LDR1_VALUE = pgm_read_byte(SQUARE_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(SQUARE_WAVE + phase2);
        break;
    case 5: // SIGMOID
        LDR1_VALUE = pgm_read_byte(SIGMOID_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(SIGMOID_WAVE + phase2);
        break;
    case 6: // NOISE
        LDR1_VALUE = pgm_read_byte(WHITENOISE_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(WHITENOISE_WAVE + phase2);
        break;
    case 7: // GAUSS
        LDR1_VALUE = pgm_read_byte(GAUSS_WAVE + phase1);
        LDR2_VALUE = pgm_read_byte(GAUSS_WAVE + phase2);
        break;
    default:
      LDR1_VALUE = 255; // Mute
      LDR2_VALUE = 255; // Mute
    break;
  }


  write_output();
  update_inputs();

  
}

void update_inputs(){
  eb1.update();
  eb2.update();
  sw1.update();
  sw2.update();
}

void drawProgressbar(int x,int y, int width,int height, int progress)
{
   progress = progress > 100 ? 100 : progress; // set the progress value to 100
   progress = progress < 0 ? 0 :progress; // start the counting to 0-100
   float bar = ((float)(width-1) / 100) * progress;
   display.drawRect(x, y, width, height, WHITE);
   display.fillRect(x+2, y+2, bar , height-4, WHITE); // initailize the graphics fillRect(int x, int y, int width, int height)
  }
